<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript">
        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;

        // Converts from degrees to radians.
        Math.radians = function(degrees) {
            return degrees * Math.PI / 180;
        };
         
        // Converts from radians to degrees.
        Math.degrees = function(radians) {
            return radians * 180 / Math.PI;
        };

        const LIGHT_INTENSITY_ADJUSTMENT = 0.1;
        var textureURL = "texture.png";
        // Variable para la posición de la cámara
        var cameraPosition = [0.0, 0.0, 20.0]; // Posición inicial de la cámara
        const flashlightCutOffAngle = 12.5; // Ángulo de corte de la linterna en grados

        // Variables para controlar la posición y orientación de la cámara
        var cameraPosition = [0.0, 0.0, 20.0];
        var cameraTarget = [0.0, 0.0, 0.0];
        var cameraUp = [0.0, 1.0, 0.0];
        var rotacionX = 0;
        var rotacionY = 0;

        var light = {
            direction: [10.0, 0.0, 0.0], // Dirección de la luz
            color: [1.0, 1.0, 1.0],
            ambient: [0.1, 0.1, 0.1],
            diffuse: [0.5, 0.5, 0.5],
            specular: [1.0, 1.0, 1.0], 

            constant:1.0, 
            linear:0.09,
            quadratic:0.032
        }; // Datos de la luz

        var cameraLight = {
            position: [0.0, 0.0, 20.0], // Dirección de la luz
            color: [1.0, 1.0, 1.0],
            cutOff: Math.cos(Math.radians(flashlightCutOffAngle))
        }; // Datos de la luz de la cámara

    </script>
    <script id="shader-vs-light" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        
        layout (location = 0) in vec3 aPos;

        uniform UBO {
            mat4 projection;
            mat4 view;
        };

        uniform mat4 model;

        void main()
        {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
    </script>
    
    <script id="shader-fs-light" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        
        out vec4 FragColor;
        
        void main()
        {
            vec3 lightColor = vec3(0.0, 1.0, 0.0);
            
            FragColor = vec4(lightColor, 1.0);
        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;

        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aTexCoord;

        uniform UBO {
            mat4 projection;
            mat4 view;
        };

        uniform mat4 model;
        out vec3 Normal;
        //Variable de salida que contendrá las coordenadas donde se aplique la textura
        out vec2 TexCoord;
        out vec3 fragPos; 

        void main()
        {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            Normal = aNormal;
            mat3 normalM = mat3( transpose(inverse( model ) ) );
            Normal = normalM * aNormal;
            fragPos = vec3(model * vec4(aPos, 1.0)); // (model * vec4(aPos, 1.0)).xyz;
            TexCoord = aTexCoord; // Asigna las coordenadas de textura a la salida
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 FragColor;
        in vec3 Normal;
        in vec3 fragPos; 

        //variables relacionadas con la textura
        uniform sampler2D diffuseTexture;
        in vec2 TexCoord;

        // Estructura para la luz direccional
        struct Light {
            vec3 direction;
            vec3 color;

            vec3 ambient;
            vec3 diffuse;
            vec3 specular;

            //atenuación 
            float constant;
            float linear;
            float quadratic;
        };

        // Estructura para la luz direccional
        struct CameraLight {
            vec3 position;  
            vec3 color;
            float cutOff;
        };
    
        uniform Light light; // Uniforme para la luz direccional
        uniform Light orbitalLight; // Variable de la luz dinamica
        uniform CameraLight cameraLight; // Variable de la luz dinamica

        void main()
        {
            vec3 objectColor = vec3(1.0, 0.0, 0.0);
            vec3 viewPos = cameraLight.position;
    
            // ambient
            float ambientStrength = 0.1;
            vec3 ambient = light.ambient * (light.color + orbitalLight.color + cameraLight.color) ;            
    
            // diffuse
            vec3 norm = normalize(Normal);
            vec3 lightDir = normalize(light.direction); // Dirección de la luz direccional
            vec3 lightDirOrbital = normalize(orbitalLight.direction); // Dirección de la luz direccional orbital
            vec3 lightDirCamera = normalize(cameraLight.position - fragPos); // Dirección de la luz de la cámara
            float diff = max(dot(norm, lightDir), 0.0);
            float diffOrbital = max(dot(norm, lightDirOrbital), 0.0); //diff de la luz orbital
            float diffCamera = max(dot(norm, lightDirCamera), 0.0); // Diff de la luz de la cámara
            vec3 diffuse = (diff + diffOrbital + diffCamera) * (light.color + orbitalLight.color + cameraLight.color); // se suman los diff y el color de las luces y ya se multiplican            
    
            // specular
            float specularStrength = 0.5;
            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(-lightDir, norm);
            vec3 reflectDirOrbital = reflect(-lightDirOrbital, norm);
            vec3 reflectDirCamera = reflect(-lightDirCamera, norm);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
            float specOrbital = pow(max(dot(viewDir, reflectDirOrbital), 0.0), 32.0);
            float specCamera = pow(max(dot(viewDir, reflectDirCamera), 0.0), 32.0);
            vec3 specular = specularStrength * (spec + specOrbital + specCamera) * (light.color + orbitalLight.color + cameraLight.color); //se suman los spec de cada luz y tambien sus colores
    
            //attenuation
            float distance    = length(light.direction - fragPos);
            float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); 
    
            vec3 result = (ambient + diffuse + specular) * attenuation;

            float angle = dot(lightDirCamera, normalize(cameraLight.position - fragPos));

            if (angle > cameraLight.cutOff) {
                // Aplica iluminación al fragmento dentro del cono de luz
                // Aquí puedes agregar cualquier cálculo adicional necesario
    
                // Texture
                vec3 texColor = texture(diffuseTexture, TexCoord).rgb;
        
                //vec3 finalColor = mix(result, texColor, 0.5); // Se mezcla el color de la textura con el resultado de la iluminación
                
                //Asignamos el color 
                FragColor = vec4(texColor, 1.0) * vec4(result,1.0);
            } else {
                // El fragmento está fuera del cono de luz, no se aplica iluminación
                // Puedes optar por no hacer nada o modificar el color del fragmento según tu necesidad
                result = vec3(0.0); // Por ejemplo, aquí se establece el color del fragmento como negro
            }
        }
    </script>
</head>
<body>
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <script type="text/javascript">
        var gl = createContext("myCanvas");

        var VAO, VBO, VBO2, VBO3, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        EBO = gl.createBuffer();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPos), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexNormal), gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexTexCoord), gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cubeTriangleIndex), gl.STATIC_DRAW);

        // SHADERS PARA EL CUBO
        var shaderProgram = new ShaderProgram();
        shaderProgram.createVertexShader(document.getElementById("shader-vs").text);
        shaderProgram.createFragmentShader(document.getElementById("shader-fs").text);
        shaderProgram.compile();
        shaderProgram.link();
        shaderProgram.autocatching();

        // SHADERS PARA LA LUZ
        var shaderProgramL = new ShaderProgram();
        shaderProgramL.createVertexShader(document.getElementById("shader-vs-light").text);
        shaderProgramL.createFragmentShader(document.getElementById("shader-fs-light").text);
        shaderProgramL.compile();
        shaderProgramL.link();
        shaderProgramL.autocatching();

        //Se crea la view
        var view = mat4.create();
        mat4.translate( view, view, [ 0.0, 0.0, -20.0 ] );

        // Carga de la textura
        var myTexture = new Image( );
        var textureID = gl.createTexture( );
        myTexture.onload = function( ) {
            gl.bindTexture(gl.TEXTURE_2D, textureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
            gl.RGBA, gl.UNSIGNED_BYTE, myTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }; 
        //Dirección de la textura
        myTexture.src = textureURL;

        var uboBuffer = gl.createBuffer();
        gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);

        const blockIndex = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");

        // Obtenemos el tamaño del bloque
        const blockSize = gl.getActiveUniformBlockParameter(shaderProgram.mCompiledShader, blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE);

        // Asignar memoria "nula" al UBO
        gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);

        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer);

        const uboVariablesNames = ["projection", "view"];

        // Obtenemos los ids
        const uboVariablesIndices = gl.getUniformIndices(shaderProgram.mCompiledShader, uboVariablesNames);

        // Obtenemos los offsets
        const uboVariablesOffset = gl.getActiveUniforms(shaderProgram.mCompiledShader, uboVariablesIndices, gl.UNIFORM_OFFSET);

        const uboVariablesInfo = {};
        uboVariablesNames.forEach((name, index) => {
            uboVariablesInfo[name] = {
                index: uboVariablesIndices[index],
                offset: uboVariablesOffset[index]
            }
        });

        let index;
        index = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgram.mCompiledShader, index, 0);

        index = gl.getUniformBlockIndex(shaderProgramL.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgramL.mCompiledShader, index, 0);

        function renderCubes(time) {
            for (var i = 0; i < cubePositions.length; i++) {
                var position = cubePositions[i];
                var color = cubeColors[i];

                // Crea la matriz de modelo para el cubo
                var model = mat4.create();
                mat4.scale(model, model, [0.75, 0.75, 0.75]);
                mat4.translate(model, model, position);
                var angle = 20 * (i+1) * time;  // Variable del angulo de rotacion
                mat4.rotate(model, model, Math.radians(angle), [1.0, 0.3, 0.0]);

                // Establece la matriz de modelo y el color para el shader del cubo
                shaderProgram.bind();
                gl.uniformMatrix4fv(shaderProgram.uniformLocations["model"], false, model);
                gl.uniform3f(shaderProgram.uniformLocations["objectColor"], color[0], color[1], color[2]);

                // Renderiza el cubo
                gl.bindVertexArray(VAO);
                gl.drawElements(gl.TRIANGLES, cubeNTriangleIndex * 3, gl.UNSIGNED_INT, 0);

                // Establece la matriz de modelo para el shader de luz
                shaderProgramL.bind();
                gl.uniformMatrix4fv(shaderProgramL.uniformLocations["model"], false, model);

                // Renderiza la luz
                gl.drawElements(gl.TRIANGLES, cubeNTriangleIndex * 3, gl.UNSIGNED_INT, 0);
            }
        }

        function renderFunc(time) {
            gl.viewport(0, 0, 500, 500);
            gl.clearColor(0.5, 0.5, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), 500 / 500 /*width/height*/, 0.001, 1000.0);
            time *= 0.001; // to seconds
            /*var angle = time * 25.0;
            var model = mat4.create();
            mat4.translate(model, model, [0.0, 0.0, 0.0]);
            mat4.rotate(model, model, Math.radians(angle), [1.0, 0.5, 0.0]);*/

            // Se establece y se activa la textura
            shaderProgram.bind( );
            gl.activeTexture(gl.TEXTURE0);
            shaderProgram.setUniform1i("diffuseTexture", 0);
            gl.bindTexture(gl.TEXTURE_2D, textureID);

            //calculo de la dirección de la luz dinamica
            var lightRadius = 5;
            var lightX = Math.cos(time) * lightRadius;
            var lightY = Math.sin(time) * lightRadius;
            
            // Pasa los datos de la luz dinamica al shader
            shaderProgram.setUniform3f("orbitalLight.direction",lightX, lightY, -1);
            shaderProgram.setUniform3f("orbitalLight.color", light.color[0], light.color[1], light.color[2]);
            // shaderProgram.setUniform3f("orbitalLight.ambient", orbitalLight.ambient[0], orbitalLight.ambient[1], orbitalLight.ambient[2]);
            // shaderProgram.setUniform3f("orbitalLight.diffuse", orbitalLight.diffuse[0], orbitalLight.diffuse[1], orbitalLight.diffuse[2]);
            // shaderProgram.setUniform3f("orbitalLight.specular", orbitalLight.specular[0], orbitalLight.specular[1], orbitalLight.specular[2]);
            
            // Pasa los datos de la luz al shader
            shaderProgram.setUniform3f("light.direction", light.direction[0], light.direction[1], light.direction[2]);
            shaderProgram.setUniform3f("light.color", light.color[0], light.color[1], light.color[2]);
            shaderProgram.setUniform3f("light.ambient", light.ambient[0], light.ambient[1], light.ambient[2]);
            shaderProgram.setUniform3f("light.diffuse", light.diffuse[0], light.diffuse[1], light.diffuse[2]);
            shaderProgram.setUniform3f("light.specular", light.specular[0], light.specular[1], light.specular[2]);

            shaderProgram.setUniform1f("light.constant", light.constant);
            shaderProgram.setUniform1f("light.linear", light.linear);
            shaderProgram.setUniform1f("light.quadratic", light.quadratic);
            
            // Pasa los datos de la luz de la camara al shader
            shaderProgram.setUniform3f("cameraLight.position", cameraLight.position[0], cameraLight.position[1], cameraLight.position[2]);
            shaderProgram.setUniform3f("cameraLight.color", cameraLight.color[0], cameraLight.color[1], cameraLight.color[2]);
            shaderProgram.setUniform3f("cameraLight.cutOff", cameraLight.cutOff);


            //shaderProgram.setUniform3f("lightPos", 10.0, 0.0, 1.0);

            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["projection"].offset,
                proj,
                0
            );
            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["view"].offset,
                view,
                0
            );

           /* shaderProgram.setUniformMat4("model", model);
            gl.bindVertexArray(VAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);*/

            shaderProgramL.bind();

            var modelLight = mat4.create();
            mat4.translate(modelLight, modelLight, light.direction); 
            mat4.scale(modelLight, modelLight, [0.25, 0.25, 0.25]);

            shaderProgramL.setUniformMat4("model", modelLight);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            //Modelado de la luz orbital
            var modelLight = mat4.create();
            mat4.translate(modelLight, modelLight, [lightX,lightY, 0.0]);
            mat4.scale(modelLight, modelLight, [0.25, 0.25, 0.25]);

            shaderProgramL.setUniformMat4("model", modelLight);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            gl.bindVertexArray(null);

            renderCubes(time);

            requestAnimationFrame(renderFunc);
        }
        
         // Función para actualizar la vista de la cámara
        function updateCameraView() {
            var target = vec3.create();
            target[0] = Math.cos(Math.radians(rotacionX));   
            target[1] = Math.sin(Math.radians(rotacionY));
            target[2] = Math.sin(Math.radians(rotacionX));
            vec3.normalize(cameraTarget,target);
            mat4.lookAt(view, cameraPosition, vec3.add(vec3.create(), cameraPosition, cameraTarget), cameraUp);
            shaderProgramL.setUniformMat4("view", view);
        }


        document.addEventListener('keydown', function(event) {
            /*
                65 => A
                68 => D
                83 => S
                87 => W
                81 => Q
                69 => E

                73 => I
                75 => K
                76 => L
                74 => J
                85 => U
                79 => O

                37 => Flecha izq
                39 => Fecha drcha
                38 => Fecha arriba
                40 => Fecha abajo

                49 => 1
                50 => 2
                51 => 3
                52 => 4 
                53 => 5
                54 => 6 
                55 => 7
                56 => 8
            

            */

            var speed = 0.1; // Velocidad de movimiento de la cámara
            var adjustment = 0.1; 
            var speedRotation = 3;
            switch(event.keyCode) {
                case 83: // S abajo
                    cameraPosition[1] -= speed; // Mover hacia abajo
                    break;

                case 87: // W arriba
                    cameraPosition[1] += speed; // Mover hacia arriba
                    break;

                case 65: // A izquierda
                    var left = vec3.create();
                    vec3.cross(left, cameraTarget, cameraUp);
                    vec3.normalize(left, left);
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, left, -speed);
                    vec3.scaleAndAdd(cameraTarget, cameraTarget, left, -speed);
                    break;

                case 68: // D derecha
                    var right = vec3.create();
                    vec3.cross(right, cameraTarget, cameraUp);
                    vec3.normalize(right, right);
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, right, speed);
                    vec3.scaleAndAdd(cameraTarget, cameraTarget, right, speed);
                    break;

                case 81: // Q
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, cameraTarget, -speed); // zoom out
                    break;
                case 69: // E
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, cameraTarget, speed); // zoom in
                    break;
            
                case 38: // flecha arriba rotacion arriba
                    rotacionY +=speedRotation;
                    break;
                case 40: // flecha abajo rotacion abajo
                    rotacionY -=speedRotation;
                    break;
                case 37: //flecha izquierda rotar izquierda
                    rotacionX -= speedRotation;                             
                    break;
                case 39: //flecha derecha rotar derecha
                    rotacionX += speedRotation;             
                    break;

                case 73:  // I luz direccional arriba
                    light.direction[1] += speed;
                    break;
                case 75: // K luz direccional abajo
                    light.direction[1] -= speed;
                    break;
                case 76: // L luz direccional derecha
                    light.direction[0] += speed;
                    break;
                case 74: // J luz direccional izquierda
                    light.direction[0] -= speed;
                    break;

                case 85: // U luz direccional adelante
                    light.direction[2] += speed;
                    break;
                case 79: // O luz direccional atras
                    light.direction[2] -= speed;
                    break;
                
                case 55: // 7 mas intensidad
                    for (let i = 0; i < 3; i++) {
                        light.ambient[i] = Math.max(0.0, Math.min(light.ambient[i] + adjustment, 1.0));
                    }
                    break;
                case 56: // 8 menos intensidad
                    for (let i = 0; i < 3; i++) {
                        light.ambient[i] = Math.max(0.0, Math.min(light.ambient[i] - adjustment, 1.0));
                    }
                    break;

                case 49: // 1 mas color rojo
                    light.color[0] += adjustment;
                    break;
                case 50: // 2 mas color verde
                    light.color[1] += adjustment;
                    break;
                case 51: // 3 mas color azul
                    light.color[2] += adjustment;
                    break;

                case 52: // 4 menos color rojo
                    light.color[0] -= adjustment;
                    break;
                case 53: // 5 menos color verde
                    light.color[1] -= adjustment;
                    break;
                case 54: // 6 menos color azul
                    light.color[2] -= adjustment;
                    break;
                    
                case 32: //Apagar la luz de la camara
                    cameraLight.color = [0.0, 0.0, 0.0]; // Apagar la luz cambiando el color a negro  
                    break;
            }
            if (event.ctrlKey) { //Encender la luz de la camara
                cameraLight.color = [1.0, 1.0, 1.0]; // Encender la luz cambiando el color a blanco  
            }
            updateCameraView();
        } );
        
        renderFunc( 0.0 );
    </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript">
        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;

        // Converts from degrees to radians.
        Math.radians = function(degrees) {
            return degrees * Math.PI / 180;
        };
         
        // Converts from radians to degrees.
        Math.degrees = function(radians) {
            return radians * 180 / Math.PI;
        };
    </script>
    <script id="shader-vs-light" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        
        layout (location = 0) in vec3 aPos;

        uniform UBO {
            mat4 projection;
            mat4 view;
        };

        uniform mat4 model;

        void main()
        {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
    </script>
    
    <script id="shader-fs-light" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        
        out vec4 FragColor;
        
        void main()
        {
            vec3 lightColor = vec3(0.0, 1.0, 0.0);
            
            FragColor = vec4(lightColor, 1.0);
        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;

        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aTexCoord;

        uniform UBO {
            mat4 projection;
            mat4 view;
        };

        uniform mat4 model;
        out vec3 Normal;
        //Variable de salida que contendrá las coordenadas donde se aplique la textura
        out vec2 TexCoord;
        out vec3 fragPos; 

        void main()
        {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            Normal = aNormal;
            mat3 normalM = mat3( transpose(inverse( model ) ) );
            Normal = normalM * aNormal;
            fragPos = vec3(model * vec4(aPos, 1.0)); // (model * vec4(aPos, 1.0)).xyz;
            TexCoord = aTexCoord; // Asigna las coordenadas de textura a la salida
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 FragColor;
        in vec3 Normal;
        in vec3 fragPos; 

        //variables relacionadas con la textura
        uniform sampler2D diffuseTexture;
        in vec2 TexCoord;

        // Estructura para la luz direccional
        struct Light {
            vec3 direction;
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
        };
    
        uniform Light light; // Uniforme para la luz direccional

        void main()
        {
            vec3 lightColor = vec3(0.0, 1.0, 0.0);
            vec3 objectColor = vec3(1.0, 0.0, 1.0);
            vec3 viewPos = vec3(0.0, 0.0, 20.0);

            // ambient
            float ambientStrength = 0.1;
            vec3 ambient = ambientStrength * lightColor;

            // diffuse
            vec3 norm = normalize(Normal);
            vec3 lightDir = normalize(-light.direction); // Dirección de la luz direccional
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * lightColor;

            // specular
            float specularStrength = 0.5;
            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(-lightDir, norm);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
            vec3 specular = specularStrength * spec * lightColor; 

            vec3 result = (ambient + diffuse + specular) * objectColor;
            FragColor = vec4(diffuse, 1.0);

            //texture
            //vec3 color = texture(diffuseTexture, TexCoord).rgb; // Lee el color de la textura en las coordenadas dadas
            //FragColor = vec4(color, 1.0);

        }
    </script>
</head>
<body>
    <canvas id="myCanvas" width="500" height="500"></canvas>
    <script type="text/javascript">
        var gl = createContext("myCanvas");

        var VAO, VBO, VBO2, VBO3, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        EBO = gl.createBuffer();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPos), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexNormal), gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexTexCoord), gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cubeTriangleIndex), gl.STATIC_DRAW);

        // SHADERS PARA EL CUBO
        var shaderProgram = new ShaderProgram();
        shaderProgram.createVertexShader(document.getElementById("shader-vs").text);
        shaderProgram.createFragmentShader(document.getElementById("shader-fs").text);
        shaderProgram.compile();
        shaderProgram.link();
        shaderProgram.autocatching();

        // SHADERS PARA LA LUZ
        var shaderProgramL = new ShaderProgram();
        shaderProgramL.createVertexShader(document.getElementById("shader-vs-light").text);
        shaderProgramL.createFragmentShader(document.getElementById("shader-fs-light").text);
        shaderProgramL.compile();
        shaderProgramL.link();
        shaderProgramL.autocatching();

        //Se crea la view
        var view = mat4.create();
        mat4.translate( view, view, [ 0.0, 0.0, -20.0 ] );


        // Carga de la textura
        var myTexture = new Image( );
        var textureID = gl.createTexture( );
        myTexture.onload = function( ) {
            gl.bindTexture(gl.TEXTURE_2D, textureID);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
            gl.RGBA, gl.UNSIGNED_BYTE, myTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }; 
        //Dirección de la textura
        myTexture.src = "texture.png";

        var uboBuffer = gl.createBuffer();
        gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);

        const blockIndex = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");

        // Obtenemos el tamaño del bloque
        const blockSize = gl.getActiveUniformBlockParameter(shaderProgram.mCompiledShader, blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE);

        // Asignar memoria "nula" al UBO
        gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);

        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer);

        const uboVariablesNames = ["projection", "view"];

        // Obtenemos los ids
        const uboVariablesIndices = gl.getUniformIndices(shaderProgram.mCompiledShader, uboVariablesNames);

        // Obtenemos los offsets
        const uboVariablesOffset = gl.getActiveUniforms(shaderProgram.mCompiledShader, uboVariablesIndices, gl.UNIFORM_OFFSET);

        const uboVariablesInfo = {};
        uboVariablesNames.forEach((name, index) => {
            uboVariablesInfo[name] = {
                index: uboVariablesIndices[index],
                offset: uboVariablesOffset[index]
            }
        });

        let index;
        index = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgram.mCompiledShader, index, 0);

        index = gl.getUniformBlockIndex(shaderProgramL.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgramL.mCompiledShader, index, 0);

        var light = {
            direction: [0.0, 0.0, -1.0], // Dirección de la luz
            ambient: [0.1, 0.1, 0.1],
            diffuse: [0.5, 0.5, 0.5],
            specular: [1.0, 1.0, 1.0]
        }; // Datos de la luz

        function renderFunc(time) {
            gl.viewport(0, 0, 500, 500);
            gl.clearColor(0.5, 0.5, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), 500 / 500 /*width/height*/, 0.001, 1000.0);
            time *= 0.001; // to seconds
            var angle = time * 25.0;
            var model = mat4.create();
            mat4.translate(model, model, [0.0, 0.0, 0.0]);
            mat4.rotate(model, model, Math.radians(angle), [1.0, 0.5, 0.0]);

            // Se establece y se activa la textura
            shaderProgram.bind( );
            gl.activeTexture(gl.TEXTURE0);
            shaderProgram.setUniform1i("diffuseTexture", 0);
            gl.bindTexture(gl.TEXTURE_2D, textureID);

            // asa los datos de la luz al shader
            shaderProgram.setUniform3f("light.direction", light.direction[0], light.direction[1], light.direction[2]);
            shaderProgram.setUniform3f("light.ambient", light.ambient[0], light.ambient[1], light.ambient[2]);
            shaderProgram.setUniform3f("light.diffuse", light.diffuse[0], light.diffuse[1], light.diffuse[2]);
            shaderProgram.setUniform3f("light.specular", light.specular[0], light.specular[1], light.specular[2]);

            shaderProgram.setUniform3f("lightPos", 10.0, 0.0, 1.0);

            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["projection"].offset,
                proj,
                0
            );
            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["view"].offset,
                view,
                0
            );

            shaderProgram.setUniformMat4("model", model);
            gl.bindVertexArray(VAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            shaderProgramL.bind();

            var modelLight = mat4.create();
            mat4.translate(modelLight, modelLight, [10.0, 0.0, 1.0]);
            mat4.scale(modelLight, modelLight, [0.25, 0.25, 0.25]);

            shaderProgramL.setUniformMat4("model", modelLight);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            gl.bindVertexArray(null);

            requestAnimationFrame(renderFunc);
        }

        // Variables para controlar la posición y orientación de la cámara
        var cameraPosition = [0.0, 0.0, 20.0];
        var cameraTarget = [0.0, 0.0, 0.0];
        var cameraUp = [0.0, 1.0, 0.0];
        var rotacionX = 0;
        var rotacionY = 0;
    
         // Función para actualizar la vista de la cámara
        function updateCameraView() {
            var target = vec3.create();
            target[0] = Math.cos(Math.radians(rotacionX));
            target[1] = Math.sin(Math.radians(rotacionY));
            target[2] = Math.sin(Math.radians(rotacionX));
            vec3.normalize(cameraTarget,target);
            mat4.lookAt(view, cameraPosition, vec3.add(vec3.create(), cameraPosition, cameraTarget), cameraUp);
            shaderProgramL.setUniformMat4("view", view);
        }

        document.addEventListener('keydown', function(event) {
            /*
                65 => A
                68 => D
                83 => S
                87 => W
                81 => Q
                69 => E

                37 => Flecha izq
                39 => Fecha drcha
                38 => Fecha arriba
                40 => Fecha abajo

            */
            var speed = 0.1; // Velocidad de movimiento de la cámara
            var speedRotation = 2.5;

            switch(event.keyCode) {
                case 83: // S abajo
                    cameraPosition[1] -= speed; // Mover hacia abajo
                    break;

                case 87: // W arriba
                    cameraPosition[1] += speed; // Mover hacia arriba
                    break;

                case 65: // A izquierda
                    var left = vec3.create();
                    vec3.cross(left, cameraTarget, cameraUp);
                    vec3.normalize(left, left);
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, left, -speed);
                    vec3.scaleAndAdd(cameraTarget, cameraTarget, left, -speed);
                    break;

                case 68: // D derecha
                    var right = vec3.create();
                    vec3.cross(right, cameraTarget, cameraUp);
                    vec3.normalize(right, right);
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, right, speed);
                    vec3.scaleAndAdd(cameraTarget, cameraTarget, right, speed);
                    break;

                case 81: // Q
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, cameraTarget, -speed); // zoom out
                    break;
                case 69: // E
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, cameraTarget, speed); // zoom in
                    break;
            
                case 38: // flecha arriba rotacion arriba
                    rotacionY +=speedRotation;
                    break;

                case 40: // flecha abajo rotacion abajo
                    rotacionY -=speedRotation;
                    break;

                case 37: //flecha izquierda rotar izquierda
                    rotacionX -= speedRotation;
                    break;
                case 39: //flecha derecha rotar derecha
                    rotacionX += speedRotation;
                    break;
            }
            updateCameraView();
        } );
        
        renderFunc( 0.0 );
    </script>
</body>
</html>